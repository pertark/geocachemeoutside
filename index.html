<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Custom Routing on GeoJSON</title>
  <link rel="stylesheet" href="https://js.arcgis.com/4.29/esri/themes/light/main.css" />
  <style>
    html, body, #viewDiv {
      height: 100%; margin: 0; padding: 0;
    }
  </style>
</head>
<body>
  <div id="viewDiv"></div>

  <!-- Load ArcGIS API -->
  <script src="https://js.arcgis.com/4.29/"></script>

  <!-- Load Turf.js from CDN -->
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6.5.0/turf.min.js"></script>

  <!-- Load Graphlib -->
  <script src="https://cdn.jsdelivr.net/npm/graphlib@2.1.8/dist/graphlib.min.js"></script>

  <script>
    require([
      "esri/Map",
      "esri/views/MapView",
      "esri/layers/GeoJSONLayer",
      "esri/Graphic"
    ], (Map, MapView, GeoJSONLayer, Graphic) => {

      const map = new Map({ basemap: "streets-navigation-vector" });

      const view = new MapView({
        container: "viewDiv",
        map: map,
        center: [-98, 39],
        zoom: 4
      });

      // Load GeoJSON
      const geojsonLayer = new GeoJSONLayer({
        url: "./network.geojson" // Ensure it's hosted locally or accessible via server
      });

      map.add(geojsonLayer);

      let graph = new graphlib.Graph({ directed: false });
      let startPoint = null, endPoint = null;

      geojsonLayer.when(() => {
        geojsonLayer.queryFeatures().then((result) => {
          result.features.forEach((feature) => {
            const coords = feature.geometry.paths[0];
            for (let i = 0; i < coords.length - 1; i++) {
              const start = coords[i];
              const end = coords[i + 1];

              const startId = start.join(',');
              const endId = end.join(',');
              const length = turf.distance(turf.point(start), turf.point(end));

              graph.setNode(startId, { coord: start });
              graph.setNode(endId, { coord: end });
              graph.setEdge(startId, endId, length);
            }
          });
        });
      });

      // Handle clicks
      view.on("click", (event) => {
        const { longitude, latitude } = event.mapPoint;
        const point = [longitude, latitude];

        if (!startPoint) {
          startPoint = point;
          view.graphics.add(new Graphic({
            geometry: { type: "point", longitude, latitude },
            symbol: { type: "simple-marker", color: "green", size: "12px" }
          }));
        } else if (!endPoint) {
          endPoint = point;
          view.graphics.add(new Graphic({
            geometry: { type: "point", longitude, latitude },
            symbol: { type: "simple-marker", color: "red", size: "12px" }
          }));

          // Compute and draw route
          const path = computeRoute(graph, startPoint, endPoint);
          if (path.length > 1) {
            const polyline = {
              type: "polyline",
              paths: [path],
              spatialReference: { wkid: 4326 }
            };
            const lineSymbol = {
              type: "simple-line",
              color: "blue",
              width: 3
            };
            view.graphics.add(new Graphic({ geometry: polyline, symbol: lineSymbol }));
          }

          // Reset for next route
          startPoint = null;
          endPoint = null;
        }
      });

      // Utility functions
      function findClosestNode(graph, point) {
        let minDist = Infinity, closestNode = null;
        graph.nodes().forEach(nodeId => {
          const coord = graph.node(nodeId).coord;
          const dist = turf.distance(turf.point(point), turf.point(coord));
          if (dist < minDist) {
            minDist = dist;
            closestNode = nodeId;
          }
        });
        return closestNode;
      }

      function computeRoute(graph, startCoord, endCoord) {
        const start = findClosestNode(graph, startCoord);
        const end = findClosestNode(graph, endCoord);
        const dijkstra = graphlib.alg.dijkstra(graph, start);

        const path = [];
        let current = end;
        while (current && current !== start) {
          path.unshift(graph.node(current).coord);
          current = dijkstra[current].predecessor;
        }

        if (current === start) {
          path.unshift(graph.node(start).coord);
        }

        return path;
      }
    });
  </script>
</body>
</html>

